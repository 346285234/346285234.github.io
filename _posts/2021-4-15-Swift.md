---
layout: post
title: Swift
categories: Languages
---

- [Swift](#swift)
  - [数据类型](#数据类型)
    - [基本类型](#基本类型)
      - [字符和字符串](#字符和字符串)
      - [枚举](#枚举)
      - [结构体](#结构体)
    - [集合](#集合)
      - [Set](#set)
    - [Optional](#optional)
  - [运算符](#运算符)
    - [运算符重载](#运算符重载)
  - [控制流](#控制流)
    - [循环](#循环)
    - [判断](#判断)
  - [函数](#函数)
    - [闭包](#闭包)
      - [逃逸闭包](#逃逸闭包)
      - [自动闭包](#自动闭包)
    - [清理](#清理)
  - [类](#类)
    - [协议](#协议)
    - [属性](#属性)
    - [方法](#方法)
    - [构造函数](#构造函数)
    - [析构函数](#析构函数)
    - [继承](#继承)
    - [访问权限](#访问权限)
    - [类型别名](#类型别名)
    - [类型转换](#类型转换)
    - [扩展](#扩展)
  - [范型](#范型)
  - [内存管理](#内存管理)
    - [weak vs unowned](#weak-vs-unowned)
    - [内存安全](#内存安全)
  - [异常](#异常)
    - [断言](#断言)

# Swift

## 数据类型
### 基本类型
Int(与系统有关), Float(32), Double(64)
Bool: true, false
Tuple: (A, B)
#### 字符和字符串
默认是UTF8，1～4个字节，需要通过index访问。
#### 枚举
```
enum EnumName {
    case name1
    ...
}

// 枚举所有case
enum EnumName: CaseIterable {}
EnumName.allCases

// 递归枚举
enum EnumName {
    case name1
    indirect case name2(EnumName)
}
```

#### 结构体
```
struct StructName {
    var value: Int
    func getValue() -> Int { return value }
    mutating func changeValue(newValue: Int) { self.value = newValue }
}
```

### 集合
Array, Set, Dictionary
#### Set
每个元素都是唯一，无序。
```
交集：intersection
并集：union
两个集合独有和：symetricDifference
当前集合独有：subtracting
```

### Optional
```
enum Optional<T> {
    case none
    case some(T)
}
```

## 运算符
```
赋值：=
计算：+-*/
求余%
复合：+=
比较：==, !=, >, <, >=, <=
引用比较： === !==
Optional默认值：??
范围：..., ..<
逻辑：!, &&, ||
位运算：&, |, ~(取反), ^(异或), <<, >>
```
### 运算符重载
prefix, infix, postfix
```
static prefix func ++(Parameter) -> ReturnType {}
```

## 控制流
### 循环
```
// For
for element in collection {}

// While
while condition {}

repeat {
} while condition

// 多层跳转，有点goto的感觉
label: while condition {
    break label
}
```

### 判断
```
// If
if condition {}

// Switch
switch value {
case value1:
...
default:
}

// Guard
guard condition else {
    return
}

// Check API Availability
if #available(iOS x, macOS x, *) {}

// Where
extension TypeName where TypeName: SomeProtocol {}
```

## 函数
```
func functionName(parameters) -> returnValue
```
### 闭包
#### 逃逸闭包
函数返回后才被调用。
```
func function(closure: @escaping () -> ()) {}
```
#### 自动闭包
```
let closure = { dosomething }
closure()
```

### 清理
方法返回前调用
```
defer {}
```

## 类
### 协议
* 声明属性
* 声明实例方法或类方法

### 属性
```
// 使用时初始化
lazy var variable = xxx

// 计算属性variable
var _variable: Type
var variable: Type {
    get { _variable }
    set { _variable = newValue }
}

// 观察set
var variable: Type {
    willSet { print(newValue) }
    didSet { print(oldValue) }
}
```

### 方法
实例方法，类方法static

### 构造函数
1. 每个类至少有一个Designated初始化方法
2. 子类的Desinated必须调用父类的Designated初始化方法
3. Convenience初始化方法必须调用同级的Designated方法
4. 如果子类没有Designated方法，会继承父类所有Designated方法
5. 如果子类有父类所有的Designated方法，会同时继承父类所有Convenience方法

```
// init!, init?初始化可以返回nil
init?(parameter) { return nil }
init!(parameter) { return nil }
// required修饰的初始化方法除非复用父类的否则每个子类必须重新实现
required init(parameter) {}
```

### 析构函数
`deinit()`

### 继承
override重载
final修饰的方法，属性，类无法重载

### 访问权限
* open： 最高权限
* public： module外无法重载和继承
* internal：module内
* fileprivate： 当前文件
* private：类内

### 类型别名
```
typealias A = Int
```

### 类型转换
`as`

### 扩展
* 增加计算属性
* 增加实例方法或类方法
* 增加初始化方法
* 增加subscripts
* 增加内部类型
* 实现新的协议
* 为协议添加默认实现

## 范型
`<T>`

## 内存管理
### weak vs unowned
unowned对象释放时不会置为nil，所以需要保证当前对象的生命周期小于unowned对象

### 内存安全
同时操作同一地址内存不安全。
单线程也可能内存不安全，比如：
```
// inout会在生命周期内长期持有当前对象的写权限
var variable = 1
func change(parameter: inout Int) {
    parameter += variable
}
change(&variable)
```

## 异常
```
func function() throws {}

do {
    try function()
} catch SomeError {
} catch OtherError {
}
```

### 断言
> assert只适用于debug，precondition适用于debug和release，
fatalError适用于开发初期，表示功能还没实现,
可以通过设置-Ounchecked屏蔽assert和precondition，但是不能屏蔽fatalError.

```
assert(condition:message:file:line)
assertionFailure(message:file:line)
precondition(condition:message:file:line)
preconditionFailure(message:file:line)
fatalError(message:file:line)
```
