---
layout: post
title: TLS Primer
categories: Security
---
互联网的通信安全是建立在TLS协议上。

本文主要介绍*为什么HTTPS比传统的HTTP更安全*，以及*如何通过SSL Pinning防止中间人攻击*。



## HTTP vs HTTPS

传统的http通信是**明文**传输，而https是**密文**传输。

HTTPS可以看作是：`HTTPS = HTTP + TLS`



## 什么是TLS

TLS是传输层协议，基本过程包括：

1. 客户端向服务器获取并验证公钥
2. 双方协商生成**对话密钥**
3. 双方使用**对话密钥**加密通信



前两步被称作"握手阶段"。



## 握手阶段

握手阶段，包括：

>1. 客户端向服务器发起请求，传输包含客户端生成的*随机数A*，TLS版本信息以及支持加密算法。
>2. 服务器回应客户端请求，返回包括服务器生成的*随机数B*，*服务器证书*和确认的TLS版本信息以及的加密算法。
>3. 客户端验证证书，通知服务器握手结束，并将生成的**随机数C(Premater secret)**用公钥加密后传给服务器。
>4. 服务器通知客户端握手结束。
>5. 双方用商议好的加密方式，使用随机数A，B，C，生成**对话密钥**。

由于握手阶段的所有内容都是明文传输，所以**对话密钥**的安全主要取决于被公钥加密过的**随机数C**。



## RSA算法

RSA非对称算法，之所以安全，*取决于现代人还无法在短期内找到一个极大数*(比如2048位，目前只有768位被破解，它的位数即是公私钥的位数)*的质数因子*。

RSA加解密过程：

>1. 生成公私钥对。公钥包含**(n, e)**，私钥包含**(n, d)**。数学原理如下：通过找到两个质数**p**，**q**，算出极大数 `n = p * q`，*φ(n)*代表与**n**互质的整数个数，随机选择与*φ(n)*互质的参数**e**，由模反定理 `ed ≡ 1(mod φ(n)) ` 得参数**d**。
>2. 加密。原始数据*m*(注：*m必须小于n*，可以通过padding将大于n的整数分成多个部分)，使用公钥加密得到结果*c*。公式：`mᵉ ≡ c(mod n)`
>3. 解密。加密结果*c*，通过私钥解密得到原始数据*m*。公式：`cᵈ ≡ m(mod n)`

详细过程及证明方法，参见：[RSA原理][]



## DH算法

虽然理论上只要公钥足够长(如2048位)，**Premaster secret**就很难被破解，但为了足够安全，我们可以采用DH算法。

DH算法不直接传输**Premaster sercret**，它的安全性取决于*目前并没有一个高效计算离散对数的方法*。

DH原理：

> 1. 用户1和用户2协定使用一对数字*(p, g)*。
> 2. 用户1选择一个小于*p*的秘密数**a**，用户2选择一个小于*p*的秘密数**b**。
> 3. 用户1通过公式 `gᵃ ≡ A(mod p)` 得到*A*，传给用户2。
> 4. 用户2通过公式 `gᵇ ≡ B(mod p)` 得到*B*，传给用户1。
> 5. 用户1，2依据本地秘密数，得到公共密钥**s**。原理：`pᵃᵇ = pᵇᵃ, Aᵇ ≡ s(mod g) ≡ Bᵃ`

DH握手：

> 1. 同握手阶段
> 2. 同握手阶段
> 3. 服务器将计算得到的数字*A*，传输给客户端。
> 4. 客户端将计算得到的数字*B*，传输给服务器。
> 5. 客户端，服务器依据本地的秘密数，计算得到**Premaster secret**，用商议好的加密方式，生成**对称密钥**。

详细描述，参见：[DH算法][]



## 中间人攻击

因为当前高位的RSA算法仍难以破解，所以一般的中间人攻击，通过在握手阶段，直接篡改服务器证书为受信任的其他证书。

本文主要介绍如何防止证书被篡改，其他中间人的攻击方式，参见：[MITM攻击][]



## SSL Pinning

SSL Pinning保证只有客户端允许的证书才能验证通过。通过在app内部事先存入证书相关信息，防止中间人攻击。

SSL Pinning验证方式可以有多种，这里介绍两种：

> 1. 通过证书比对。这种方式比较简单，直接将服务器某级证书如叶节点证书存在app内部，当发起网络请求时，与从服务器得到的证书进行比对，相同，则说明证书没有被篡改。缺点是本地的证书可以在app package的resource下直接看到，可能被修改。
> 2. 通过签名验证。在服务器端对服务器某级证书如叶节点证书加签(注：这里的签名和证书的签名结果是不一样的，证书的签名只是对证书内容的签名)，将结果存在app代码中，当发起网络请求，将得到的服务器证书，公钥和本地的签名三者做签名验证，相同，则说明证书是服务器证书。

相关代码见[Use SSL Pinning in macOS][](注：由于Charles代理只有二级证书，叶节点证书没办法替换成自签名证书，代码中通过更换root证书测试)

缺点：如果服务器证书更新，app内部的信息也需要及时更新，否则将造成验证失败。



*参考:*

[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

[SSL Pinning for Increased App Securtity](https://possiblemobile.com/2013/03/ssl-pinning-for-increased-app-security/)

[RSA算法原理](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

[图解TLS](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)

[MITM攻击]: http://www.jianshu.com/p/a825de42ccbc
[Use SSL Pinning in macOS]: https://github.com/346285234/CQSSLPinning
[RSA原理]: http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html
[DH算法]: https://zh.wikipedia.org/wiki/迪菲-赫爾曼密鑰交換