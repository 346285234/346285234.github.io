---
layout: post
title: 深入理解操作系统
categories: 操作系统
---

- [深入理解操作系统](#深入理解操作系统)
  - [漫游](#漫游)
    - [概念](#概念)
      - [编译过程](#编译过程)
      - [硬件组成](#硬件组成)
      - [CPU操作](#cpu操作)
      - [程序执行过程](#程序执行过程)
      - [存储设备层次](#存储设备层次)
      - [内核](#内核)
      - [进程和线程](#进程和线程)
      - [虚拟内存](#虚拟内存)
      - [文件](#文件)
      - [网络通信](#网络通信)
      - [Amdahl定律](#amdahl定律)
      - [并发和并行](#并发和并行)
      - [计算机系统抽象表示](#计算机系统抽象表示)
    - [总结](#总结)
  - [信息表示](#信息表示)
    - [大端和小端](#大端和小端)
    - [位运算](#位运算)
    - [掩码运算](#掩码运算)
    - [逻辑运算](#逻辑运算)
    - [移位](#移位)
    - [整数补码](#整数补码)
      - [加法逆元](#加法逆元)
      - [反码](#反码)
      - [原码](#原码)
    - [整数运算](#整数运算)
    - [浮点数](#浮点数)
      - [数值](#数值)
    - [总结](#总结-1)
  - [链接](#链接)

# 深入理解操作系统

## 漫游
### 概念
#### 编译过程
1. 预处理：将头文件插入源文件，得到.i
2. 编译：翻译成汇编程序，得到.s
3. 汇编：翻译成机器指令, 得到目标文件.o
4. 链接：和引用到的其他目标文件合并，得到可执行文件

#### 硬件组成
* 总线： 以字长为单位传送数据，32位系统一个字是32位
* I/O设备
* 主存：DRAM
* CPU：核心是PC寄存器，它指向主存中将要执行的机器指令

#### CPU操作
* 加载： 从主存复制数据到寄存器
* 存储：从寄存器复制数据到主存
* 操作：将两个寄存器内容复制到ALU执行算术计算，然后将结果存到寄存器
* 跳转：从指令中得到地址复制到PC

#### 程序执行过程
1. shell程序等待输入
2. 当我们输入后，shell程序将字符读入寄存器，再把它存入内存
3. 当我们输入回车后，shell执行指令将hello目标文件的代码和数据从磁盘直接复制到内存
4. 处理器开始执行程序main的机器代码

#### 存储设备层次
0. 寄存器
1. L1高速缓存(SRAM)
2. L2高速缓存(SRAM)
3. L3高速缓存(SRAM)
4. 主存(DRAM)
5. 本地磁盘
6. 远程存储

#### 内核
内核不是独立的进程，它是系统管理全部进程的代码和数据结构的集合，是操作系统常驻主存的部分。
当应用程序做某些系统调用时，它会把控制权转移到内核。

#### 进程和线程
进程是一个正在运行的程序的抽象，它有独立的上下文，并发运行实质上是进程的交错执行，需要上下文切换。
一个进程可以有多个线程，线程运行在同一个进程的上下文，共享进程的代码和全局数据。

#### 虚拟内存
进程所使用内存的抽象，分成多个区域：
* 程序代码和静态数据，大小在进程开始运行时就确定了
* 堆
* 共享库
* 栈
* 内核，用户代码不可见

#### 文件
文件就是字节序列，I/O设备，磁盘，网络等都可以看成文件。
系统所有输入输出都是通过读写文件实现。

#### 网络通信
从单独的系统看，网络可以看成一个I/O设备，数据可以从主存到网络，也可以从网络到主存。

#### Amdahl定律
计算机加速比`S=1/((1-a)+a/k)`, 其中a是性能提升部件占比，k是提升比例。

#### 并发和并行
并发是一个通用概念，指同时有多个活动；并行指的是用并发使系统更快。
1. 线程级并发：交错执行，多核，超线程（超线程处理器CPU有多个备份，能更快的进行线程切换）
2. 指令级并行：通过流水线技术将一条指令分成多个步骤，并行处理多个指令
3. 单指令多数据并行：一条指令产生多个并行操作

#### 计算机系统抽象表示
* 文件～I/O设备
* 虚拟内存～主存+I/O设备
* 处理器～指令级架构
* 进程～处理器+主存+I/O设备
* 虚拟机～操作系统+处理器+主存+I/O设备

### 总结
* 计算机包括CPU，总线，主存，I/O设备，网络可以看作I/O设备。
* 内核是硬件和应用程序的媒介，文件，虚拟内存和进程是对硬件的抽象表示。
* 程序从ASCII文件，经过编译，转成二进制。
* 执行程序花费大量时间在数据复制，所以需要多级缓存。
* 多进程，多线程通过并发提高程序运行效率。

## 信息表示
### 大端和小端
* 大端：从最高位到最低位存储
* 小端：从最低位到最高位存储
iOS和Android只支持小端。
字符串因为最后一个字符是null, 所以无论大端小端，都是从左往右存储。

### 位运算
&，|, ~, ^ - 与，或，非，异或

### 掩码运算
通过&如0xff，取出某一部分。

### 逻辑运算
&&, ||, ! - 与，或，非
结果是True, False

### 移位
`<<k`: 左移k位，去掉最高k位，右边补0
`>>k`
* 逻辑右移：右移k位，去掉最低k位，最高k位补0
* 算术右移：右移k位，去掉最低k位，最高k位补最高位

有符号算术右移，无符号逻辑右移。

### 整数补码
补码，原码，反码都是对数字的解释方法，不改变数字。
最高有效位为负，加上其他位，如：
```
[0001] = -0*2^3+0*2^2+0*2^1+1*2^0=1
[1011] = -1*2^3+0*2^2+1*2^1+1*2^0=-5
```
#### 加法逆元
~x+1是x的加法逆元，等于-x。

#### 反码
最高位是2^w-1，加上其他位，如：
```
[1011] = -1*(2^3-1)+1*2^1+1*2^0=-4
```
#### 原码
最高位只表示符号，乘以其他位，如:
```
[1011] = -1*(2^1+2^0)=-3
```
### 整数运算
一个有符号，一个无符号，为将有符号隐式转换成无符号再计算，
对于算术运算差异不大，但是对于关系运算符可能变化很大，如-1<0u是false.

### 浮点数
近似表示一个小数。
表达式：`V=(-1)^s * M * 2^E`

浮点数二进制拆分成三块，s,f,e.
单精度:
s：1位， f：23位，e：8位
双精度:
s:1, f:52, e:10

#### 数值
1. e非全零或全1，E=e-(2^(k-1)-1), M=1+f
2. e全零, E=1-(2^(k-1)-1), M=f
3. e全1,f全零，表示无穷
4. e全1，f不全零，表示NaN，即Not a Number

### 总结
1. 大端小端影响非字符串数据存储顺序。


## 链接
链接时机：
1. 编译时
2. 加载时
3. 运行时

静态链接过程：
1. 符号解析：定义和引用建立关联。
2. 重定位：定义与内存建立关联，重定位数据和代码节，使引用指向内存。